'use client';

import React, { createContext, useState, useEffect } from 'react';
import { createUser, updateUserById, deleteUserById, verifyUserPassword } from '@/lib/server/userActions';

// INTERFACES

// # KEY POINT: We define the interface for the context value, not the provider.
// Because the provider only distributes the data â€” it's the context that holds and types it.

// USER INTERFACE
export interface User {
  id: string;
  email: string;
  name: string;
  role: 'user' | 'admin';
  password?: string; // TODO: IT MUST BE HASHED LATER
}

// CONTEXT
interface UserContextType {
  users: User[];
  currentUser: User | null;
  addUser: (user: Omit<User, 'id'>) => Promise<void>; // ID IS NOT NEEDED FOR ADDING USER (IT IS GENERATED BY THE SYSTEM)
  updateUser: (id: string, user: Partial<User>) => Promise<void>; // WE USE PARTIAL USER BECAUSE WE ALLOWED TO UPDATE ONLY SOME OF THE USER'S FIELDS
  deleteUser: (id: string) => Promise<void>;
  setCurrentUser: (user: User | null) => void;
  logout: () => void;
  verifyPassword: (userId: string, password: string) => Promise<boolean>;
}

// IMPORTANT: WE MUST USE CONTEXT TO SHARE THE USER DATA BETWEEN THE COMPONENTS
export const UserContext = createContext<UserContextType | undefined>(undefined);

// PROVIDER
export function UserProvider({ children, initialUsers = [] }: { children: React.ReactNode, initialUsers?: User[] }) { 
  // WE MUST USE PROVIDER TO PROVIDE THE USER DATA TO THE COMPONENTS (WE CANNOT USE CONTEXT DIRECTLY)
  const [users, setUsers] = useState<User[]>(initialUsers);
  const [currentUser, setCurrentUser] = useState<User | null>(null);

  // LOAD DATA FROM SESSION STORAGE (client-side only)
  useEffect(() => {
    const storedCurrentUser = sessionStorage.getItem('currentUser');
    
    if (storedCurrentUser) {
      setCurrentUser(JSON.parse(storedCurrentUser));
    }
  }, []); 

  useEffect(() => {
    if (currentUser) {
      sessionStorage.setItem('currentUser', JSON.stringify(currentUser));
    }
  }, [currentUser]);

  //METHODS

  // ADD USER
  const addUser = async (user: Omit<User, 'id'>) => {
    try {
      const newUser = await createUser(user);
      setUsers([...users, newUser]);
      return;
    } catch (error) {
      console.error('Failed to add user:', error);
      throw error;
    }
  };

  // UPDATE USER
  const updateUser = async (id: string, updatedUserData: Partial<User>) => {
    try {
      const updatedUser = await updateUserById(id, updatedUserData);
      const updatedUsers = users.map(user => {
        if (user.id === id) {
          return { ...user, ...updatedUser };
        }
        return user;
      });
      setUsers(updatedUsers);
    } catch (error) {
      console.error('Failed to update user:', error);
      throw error;
    }
  };

  // DELETE USER
  const deleteUser = async (id: string) => {
    try {
      await deleteUserById(id);
      setUsers(users.filter(user => user.id !== id));
    } catch (error) {
      console.error('Failed to delete user:', error);
      throw error;
    }
  };

  // LOGOUT
  const logout = () => {
    setCurrentUser(null);
    sessionStorage.removeItem('currentUser');
  };

  // VERIFY PASSWORD
  const verifyPassword = async (userId: string, password: string): Promise<boolean> => {
    try {
      return await verifyUserPassword(userId, password);
    } catch (error) {
      console.error('Failed to verify password:', error);
      return false;
    }
  };

  return (
    <UserContext.Provider value={{
      users,
      currentUser,
      addUser,
      updateUser,
      deleteUser,
      setCurrentUser,
      logout,
      verifyPassword,
    }}>
      {children}
    </UserContext.Provider>
  );
} 